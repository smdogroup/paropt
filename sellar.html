<!DOCTYPE html>
<html class="writer-html5" lang="python" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Sellar problem &mdash; ParOpt  documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="_static/jquery.js?v=5d32c60e"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js?v=a888008e"></script>
        <script src="_static/doctools.js?v=888ff710"></script>
        <script src="_static/sphinx_highlight.js?v=4825356b"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
        <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Parallel Rosenbrock" href="parallel_rosenbrock.html" />
    <link rel="prev" title="Rosenbrock example" href="rosenbrock.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            ParOpt
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="options.html">Options and generic interface for ParOpt optimziers</a></li>
<li class="toctree-l1"><a class="reference internal" href="rosenbrock.html">Rosenbrock example</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Sellar problem</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#c-implementation">C++ implementation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#python-implementation">Python implementation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="parallel_rosenbrock.html">Parallel Rosenbrock</a></li>
<li class="toctree-l1"><a class="reference internal" href="openmdao_example.html">OpenMDAO example</a></li>
<li class="toctree-l1"><a class="reference internal" href="parallel_openmdao_example.html">Parallel OpenMDAO example</a></li>
<li class="toctree-l1"><a class="reference internal" href="notebooks/sparse.html">General Sparse Constraints</a></li>
<li class="toctree-l1"><a class="reference internal" href="reference.html">Class reference</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">ParOpt</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Sellar problem</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="sellar-problem">
<h1>Sellar problem<a class="headerlink" href="#sellar-problem" title="Permalink to this heading"></a></h1>
<p>To illustrate the application of ParOpt, consider the following optimization problem with the Sellar objective function:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
    \text{min} \qquad &amp; x_1 + x_2^2 + x_3 + e^{-x_4} \\
    \text{with respect to} \qquad &amp; 0 \le x_{1} \le 10 \\
    &amp;  0 \le x_{2} \le 10 \\
    &amp; -1 \le x_{3} \le 3.16 \\
    &amp; -1 \le x_{4} \le 24 \\
    \text{subject to} \qquad &amp; x_{1} + x_{2} - 1 \ge 0 \\
\end{align}\end{split}\]</div>
<section id="c-implementation">
<h2>C++ implementation<a class="headerlink" href="#c-implementation" title="Permalink to this heading"></a></h2>
<p>The first step to use the ParOpt optimization library is to create a problem class which inherits from ParOptProblem.
This class is used by ParOpt's interior-point or trust-region algorithms to get the function and gradient values from the problem.</p>
<p>Key functions required for the implementation of a ParOptProblem class are described below.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">getVarsAndBounds</span><span class="p">(</span><span class="w"> </span><span class="n">ParOptVec</span><span class="w"> </span><span class="o">*</span><span class="n">xvec</span><span class="p">,</span>
<span class="w">                       </span><span class="n">ParOptVec</span><span class="w"> </span><span class="o">*</span><span class="n">lbvec</span><span class="p">,</span><span class="w"> </span><span class="n">ParOptVec</span><span class="w"> </span><span class="o">*</span><span class="n">ubvec</span><span class="w"> </span><span class="p">);</span>
</pre></div>
</div>
<p>To begin the optimization problem, the optimizer must know the starting point and the variable bounds for the problem
The member function getVarsAndBounds retrieves this information.
On return, the initial design variables are written to the design vector x, and the lower and upper bounds are written to the vectors lb and ub, respectively.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">evalObjCon</span><span class="p">(</span><span class="w"> </span><span class="n">ParOptVec</span><span class="w"> </span><span class="o">*</span><span class="n">xvec</span><span class="p">,</span>
<span class="w">                </span><span class="n">ParOptScalar</span><span class="w"> </span><span class="o">*</span><span class="n">fobj</span><span class="p">,</span><span class="w"> </span><span class="n">ParOptScalar</span><span class="w"> </span><span class="o">*</span><span class="n">cons</span><span class="w"> </span><span class="p">);</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">evalObjConGradient</span><span class="p">(</span><span class="w"> </span><span class="n">ParOptVec</span><span class="w"> </span><span class="o">*</span><span class="n">xvec</span><span class="p">,</span>
<span class="w">                        </span><span class="n">ParOptVec</span><span class="w"> </span><span class="o">*</span><span class="n">gvec</span><span class="p">,</span><span class="w"> </span><span class="n">ParOptVec</span><span class="w"> </span><span class="o">**</span><span class="n">Ac</span><span class="w"> </span><span class="p">);</span>
</pre></div>
</div>
<p>The class inheriting from ParOptProblem must also implement member functions to evaluate the objective and constraints and their gradients.
The function evalObjCon takes in the design vector x, and returns a scalar value in fobj, and an array of the dense constraint values in cons.
When the code is run in parallel, the same objective value and constraint values must be returned on all processors.
The function evalObjConGradient sets the values of the objective and constraint gradients into the vector gvec, and the array of vectors Ac, respectively.
If an error is encountered during the evaluation of either the functions or gradients, a non-zero error code should be returned to terminate the optimization.</p>
<p>When implemented in C++, the complete Sellar problem is:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;ParOptInteriorPoint.h&quot;</span>

<span class="cm">/*</span>
<span class="cm">  The following is a simple implementation of a Sellar function with</span>
<span class="cm">  constraints that can be used to test the parallel optimizer.</span>
<span class="cm">*/</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Sellar</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">ParOptProblem</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">nvars</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">ncon</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">  </span><span class="n">Sellar</span><span class="p">(</span><span class="n">MPI_Comm</span><span class="w"> </span><span class="n">_comm</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">ParOptProblem</span><span class="p">(</span><span class="n">_comm</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">setProblemSizes</span><span class="p">(</span><span class="n">nvars</span><span class="p">,</span><span class="w"> </span><span class="n">ncon</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="n">setNumInequalities</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">//! Create the quasi-def matrix associated with this problem</span>
<span class="w">  </span><span class="n">ParOptQuasiDefMat</span><span class="w"> </span><span class="o">*</span><span class="n">createQuasiDefMat</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">nwblock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ParOptQuasiDefBlockMat</span><span class="p">(</span><span class="k">this</span><span class="p">,</span><span class="w"> </span><span class="n">nwblock</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">//! Get the variables/bounds</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">getVarsAndBounds</span><span class="p">(</span><span class="n">ParOptVec</span><span class="w"> </span><span class="o">*</span><span class="n">xvec</span><span class="p">,</span><span class="w"> </span><span class="n">ParOptVec</span><span class="w"> </span><span class="o">*</span><span class="n">lbvec</span><span class="p">,</span><span class="w"> </span><span class="n">ParOptVec</span><span class="w"> </span><span class="o">*</span><span class="n">ubvec</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// declare design variable and bounds vector</span>
<span class="w">    </span><span class="n">ParOptScalar</span><span class="w"> </span><span class="o">*</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">lb</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">ub</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// store the memory addresses of the class variables</span>
<span class="w">    </span><span class="n">xvec</span><span class="o">-&gt;</span><span class="n">getArray</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">);</span>
<span class="w">    </span><span class="n">lbvec</span><span class="o">-&gt;</span><span class="n">getArray</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lb</span><span class="p">);</span>
<span class="w">    </span><span class="n">ubvec</span><span class="o">-&gt;</span><span class="n">getArray</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ub</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Set the initial design variables</span>
<span class="w">    </span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">2.0</span><span class="p">;</span>
<span class="w">    </span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0</span><span class="p">;</span>
<span class="w">    </span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">;</span>
<span class="w">    </span><span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// set lower and upper bounds to design variables</span>
<span class="w">    </span><span class="n">lb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">;</span>
<span class="w">    </span><span class="n">lb</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">;</span>
<span class="w">    </span><span class="n">lb</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">-1.0</span><span class="p">;</span>
<span class="w">    </span><span class="n">lb</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">-1.0</span><span class="p">;</span>
<span class="w">    </span><span class="n">ub</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">10.0</span><span class="p">;</span>
<span class="w">    </span><span class="n">ub</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">10.0</span><span class="p">;</span>
<span class="w">    </span><span class="n">ub</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">3.16</span><span class="p">;</span>
<span class="w">    </span><span class="n">ub</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">24.0</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">//! Evaluate the objective and constraints</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">evalObjCon</span><span class="p">(</span><span class="n">ParOptVec</span><span class="w"> </span><span class="o">*</span><span class="n">xvec</span><span class="p">,</span><span class="w"> </span><span class="n">ParOptScalar</span><span class="w"> </span><span class="o">*</span><span class="n">fobj</span><span class="p">,</span><span class="w"> </span><span class="n">ParOptScalar</span><span class="w"> </span><span class="o">*</span><span class="n">cons</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// declare local variables</span>
<span class="w">    </span><span class="n">ParOptScalar</span><span class="w"> </span><span class="o">*</span><span class="n">x</span><span class="p">;</span>
<span class="w">    </span><span class="n">xvec</span><span class="o">-&gt;</span><span class="n">getArray</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// the objective function</span>
<span class="w">    </span><span class="o">*</span><span class="n">fobj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>
<span class="w">    </span><span class="n">cons</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">1.0</span><span class="p">;</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">//! Evaluate the objective and constraint gradients</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">evalObjConGradient</span><span class="p">(</span><span class="n">ParOptVec</span><span class="w"> </span><span class="o">*</span><span class="n">xvec</span><span class="p">,</span><span class="w"> </span><span class="n">ParOptVec</span><span class="w"> </span><span class="o">*</span><span class="n">gvec</span><span class="p">,</span><span class="w"> </span><span class="n">ParOptVec</span><span class="w"> </span><span class="o">**</span><span class="n">Ac</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// define the local variables</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">g</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// get the local variables values</span>
<span class="w">    </span><span class="n">xvec</span><span class="o">-&gt;</span><span class="n">getArray</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// derivative of the objective function wrt to the DV</span>
<span class="w">    </span><span class="n">gvec</span><span class="o">-&gt;</span><span class="n">zeroEntries</span><span class="p">();</span>
<span class="w">    </span><span class="n">gvec</span><span class="o">-&gt;</span><span class="n">getArray</span><span class="p">(</span><span class="o">&amp;</span><span class="n">g</span><span class="p">);</span>
<span class="w">    </span><span class="n">g</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0</span><span class="p">;</span>
<span class="w">    </span><span class="n">g</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">2.0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="w">    </span><span class="n">g</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0</span><span class="p">;</span>
<span class="w">    </span><span class="n">g</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>

<span class="w">    </span><span class="c1">// Derivative of the constraint</span>
<span class="w">    </span><span class="n">Ac</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">zeroEntries</span><span class="p">();</span>
<span class="w">    </span><span class="n">Ac</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">getArray</span><span class="p">(</span><span class="o">&amp;</span><span class="n">g</span><span class="p">);</span>
<span class="w">    </span><span class="n">g</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0</span><span class="p">;</span>
<span class="w">    </span><span class="n">g</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0</span><span class="p">;</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">argv</span><span class="p">[])</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">MPI_Init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">argv</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// Allocate the Sellar function</span>
<span class="w">  </span><span class="n">Sellar</span><span class="w"> </span><span class="o">*</span><span class="n">sellar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Sellar</span><span class="p">(</span><span class="n">MPI_COMM_SELF</span><span class="p">);</span>
<span class="w">  </span><span class="n">sellar</span><span class="o">-&gt;</span><span class="n">incref</span><span class="p">();</span>

<span class="w">  </span><span class="c1">// Allocate the optimizer with default options</span>
<span class="w">  </span><span class="n">ParOptInteriorPoint</span><span class="w"> </span><span class="o">*</span><span class="n">opt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ParOptInteriorPoint</span><span class="p">(</span><span class="n">sellar</span><span class="p">);</span>
<span class="w">  </span><span class="n">opt</span><span class="o">-&gt;</span><span class="n">incref</span><span class="p">();</span>

<span class="w">  </span><span class="n">opt</span><span class="o">-&gt;</span><span class="n">checkGradients</span><span class="p">(</span><span class="mf">1e-6</span><span class="p">);</span>

<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="n">start</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MPI_Wtime</span><span class="p">();</span>
<span class="w">  </span><span class="n">opt</span><span class="o">-&gt;</span><span class="n">optimize</span><span class="p">();</span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="n">diff</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MPI_Wtime</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">start</span><span class="p">;</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Time taken: %f seconds </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">diff</span><span class="p">);</span>

<span class="w">  </span><span class="n">sellar</span><span class="o">-&gt;</span><span class="n">decref</span><span class="p">();</span>
<span class="w">  </span><span class="n">opt</span><span class="o">-&gt;</span><span class="n">decref</span><span class="p">();</span>

<span class="w">  </span><span class="n">MPI_Finalize</span><span class="p">();</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The local components of the design vector can be accessed by making a call to getArray.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">ParOptScalar</span><span class="w"> </span><span class="o">*</span><span class="n">x</span><span class="p">;</span>
<span class="n">xvec</span><span class="o">-&gt;</span><span class="n">getArray</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">);</span>
</pre></div>
</div>
<p>In this case, the code can only be run in serial, so the design vector is not distributed.</p>
<p>All objects in ParOpt are reference counted.
Use incref() to increase the reference count after an object is allocated.
When the object is no longer needed, call decref() to decrease the reference count and possibly delete the object.
Direct calls to delete the object should not be used.</p>
</section>
<section id="python-implementation">
<h2>Python implementation<a class="headerlink" href="#python-implementation" title="Permalink to this heading"></a></h2>
<p>The python implementation of this problem is also straightforward.
In an analogous manner, the python implemenation uses a class inherited from ParOpt.Problem, a python wrapper for the CyParOptProblem class.
This inherited class must implement a getVarsAndBounds, evalObjCon and evalObjConGradient member functions.
Note that in python, the function signature is slightly different for evalObjCon.
Please note, the vectors returned to python access the underlying memory in ParOpt directly, therefore sometimes care must be taken to avoid expressions that do not assign values to the references returned from ParOpt.
These vectors are of type ParOpt.PVec, but act in many ways like a numpy array.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">mpi4py</span> <span class="kn">import</span> <span class="n">MPI</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">paropt</span> <span class="kn">import</span> <span class="n">ParOpt</span>


<span class="c1"># Create the rosenbrock function class</span>
<span class="k">class</span> <span class="nc">Sellar</span><span class="p">(</span><span class="n">ParOpt</span><span class="o">.</span><span class="n">Problem</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Initialize the base class</span>
        <span class="n">nvars</span> <span class="o">=</span> <span class="mi">4</span>
        <span class="n">ncon</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Sellar</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">MPI</span><span class="o">.</span><span class="n">COMM_SELF</span><span class="p">,</span> <span class="n">nvars</span><span class="o">=</span><span class="n">nvars</span><span class="p">,</span> <span class="n">ncon</span><span class="o">=</span><span class="n">ncon</span><span class="p">)</span>

        <span class="k">return</span>

    <span class="k">def</span> <span class="nf">getVarsAndBounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">lb</span><span class="p">,</span> <span class="n">ub</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set the values of the bounds&quot;&quot;&quot;</span>

        <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">2.0</span>
        <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="n">lb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">lb</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">lb</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span>
        <span class="n">lb</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span>

        <span class="n">ub</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">10.0</span>
        <span class="n">ub</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">10.0</span>
        <span class="n">ub</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mf">3.16</span>
        <span class="n">ub</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mf">24.0</span>
        <span class="k">return</span>

    <span class="k">def</span> <span class="nf">evalObjCon</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Evaluate the objective and constraint&quot;&quot;&quot;</span>
        <span class="n">fail</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">fobj</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
        <span class="n">cons</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">fail</span><span class="p">,</span> <span class="n">fobj</span><span class="p">,</span> <span class="n">cons</span>

    <span class="k">def</span> <span class="nf">evalObjConGradient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">A</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Evaluate the objective and constraint gradient&quot;&quot;&quot;</span>
        <span class="n">fail</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">g</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="n">g</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">g</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="n">g</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>

        <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>

        <span class="k">return</span> <span class="n">fail</span>


<span class="c1"># Allocate the optimization problem</span>
<span class="n">problem</span> <span class="o">=</span> <span class="n">Sellar</span><span class="p">()</span>

<span class="c1"># Set up the optimization problem</span>
<span class="n">options</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">opt</span> <span class="o">=</span> <span class="n">ParOpt</span><span class="o">.</span><span class="n">Optimizer</span><span class="p">(</span><span class="n">problem</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>
<span class="n">opt</span><span class="o">.</span><span class="n">optimize</span><span class="p">()</span>
</pre></div>
</div>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="rosenbrock.html" class="btn btn-neutral float-left" title="Rosenbrock example" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="parallel_rosenbrock.html" class="btn btn-neutral float-right" title="Parallel Rosenbrock" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Graeme Kennedy.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>